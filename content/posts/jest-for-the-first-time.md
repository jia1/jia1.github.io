---
title: "Jest for the First Time"
date: 2020-09-13T21:56:00+08:00
draft: false
tags: ["software","testing","javascript","jest"]
---
To test a feature which I have been building for GovTech's FormSG, I had to mock a function in the superclass of an instance which is generated by a factory method call. I once considered stripping away the unnecessary barriers between the mock and the test, but I didn't want to refactor a codebase which I am not too familiar with.

Below is a visualisation of the "barriers" between the mock and the test:

- Test calls a method. I couldn't understand why the method is not in the test folder. Update: Perhaps the actual main code is using this method too.
- Method calls a factory method which creates an instance whose method is what I want to mock.
- The method which I want to mock is defined in the superclass of the instance.

At first, I made the mistake of calling `jest.mock(...)` on the superclass. When I switched to mocking the child class and overriding the target method in the child class with the mock, the tests passed. I had to create a `__mocks__` folder which the mock will reside in, copy the code of the child class into the mock (which is of the same name as the child class) and override the target method by defining it in the mock.

```javascript
// Suppose I'm mocking someMethod() of Blah in Blah.js:
// In the folder containing Blah.js, create __mocks__/Blah.js:
class Blah extends BlahParent {
  // Paste original code of Blah here

  someMethod() {
    // Mock implementation here
  }
}

// Test file
jest.mock('path to Blah.js');

// Everything else remains the same
```

I didn't like this approach because I had to copy code from the real child class. What if the implementation of the real child class is changed? The mock wouldn't get updated.

My buddy recommended the following changes to the test file:

```javascript
import Blah from './Blah';
import { mocked } from 'ts-jest/utils';

jest.mock('./Blah')
const MockBlah = mocked(Blah, true);
MockBlah.someMethod.mockReturnValue('Whatever I want.');
```

I got the following error: `Property 'someMethod' does not exist on type 'MockedObjectDeep<typeof Blah>'.` After some googling, I got reminded of the `prototype` field in JavaScript objects. Perhaps I should be using `MockBlah.prototype.someMethod` instead.

On the other hand, the [suggested way to mock a single function](https://stackoverflow.com/questions/50091438/jest-how-to-mock-one-specific-method-of-a-class) was through a Jest `spyOn` and `mockImplementation` call, like:

```javascript
jest.spyOn(Blah.prototype, 'someMethod').mockImplementation(() => 'Whatever I want.');
// Test code here
```

I also read the [Jest docs](https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname) to confirm my findings. In contrast, I did not verify the cause of the `Property does not exist on type` error. Would you do the honours...?
